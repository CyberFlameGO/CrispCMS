/*! \page devplugin Developing Plugins
\tableofcontents{html,latex}

Plugin documentation for Crisp

\section intro Directory Structure

\verbatim
.
└── plugins/
    └── your_plugin_folder/ - This is your plugin folder name, all lowercase, no spaces
        ├── includes/ - Here lies the PHP code for templates
        │   ├── api/ - Files in here will be executed when calling their api interface => export.php => /api/export/
        │   └── views/ - Files in here will be executed when visiting their page. welcome.php => /en/welcome
        │   └── cron.php - This file will be executed when a cron is called
        ├── templates/ - This is the template directory to store the twig tpls in
        │   └── views/ - Files in here will be rendered when visiting their page. welcome.twig => /en/welcome
        ├── hook.php - The hook file gets called regardless which page is opened
        └── plugin.json - Metadata, the heart of your plugin
\endverbatim

It is important that each twig template, needs their respective PHP code.

If you want to create a page which can be called at /en/welcome the directory structure has to look like this:

\verbatim
.
└── plugins/
    └── your_plugin_folder/
        ├── includes/
        │   ├── api/
        │   └── views/
        │       └── welcome.php - CREATE THIS FILE
        ├── templates/
        │   └── views/
        │       └── welcome.twig - CREATE THIS FILE
        ├── hook.php
        └── plugin.json
\endverbatim

\section metadata plugin.json - In detail

The plugin.json file is the heart of your plugin. It can create config keys, translations, languages, uninstall plugins, install plugins and more for you automatically.

Example plugin.json
\verbatim
{
    "name": "Hello World Plugin",
    "description": "Tutorial plugin plugin for CrispCMS",
    "hookFile": "hook.php",
    "author": "Justin René Back <jback@pixelcatproductions.net>",
    "onInstall": {
        "createTranslationKeys": {
            "en": {
                "hello_world": "Hello World"
            },
            "de": {
                "hello_world": "Hallo Welt"
            }
        },
        "createKVStorageItems": {
            "display_hello_world": true
        },
        "activateDependencies": []
    },
    "onUninstall": {
        "deleteData": true,
        "deactivateDependencies": [],
        "purgeDependencies": []
    }
}
\endverbatim


\subsection pluginname name - The name of your plugin
This property contains the full name of your plugin, you can use all characters you want. This will be shown when installing a plugin


\subsection plugindesc description - The description of your plugin
This property defines a description which is shown when listing your plugin. Keep it short


\subsection pluginhook hookFile - The name of your hook file
A hook file executes code on every page. More about this property is defined below.

\subsection pluginauthor author - Your name, for credits

Simply your name

\subsection plugininstall onInstall - Configure your plugin on installation

onInstall offers a variety of options which get executed when installing the plugin. 

All data specified in onInstall is automatically purged upon removal of the plugin, if deleteData is set to true

\subsubsection plugininstalltranslation createTranslationKeys - Creates translations when installing the plugin

Translations are created using multi-dimensional arrays/keys

The structure is as follows:

\verbatim
{
	"en": {
		"hello_world": "Hello World"
	},
	"de": {
		"hello_world": "Hallo Welt"
	}
}
\endverbatim

You can use any language key, even if it does not exist, it will be created when installing the plugin.


\subsubsection plugininstallstorage createKVStorageItems - Creates config keys when installing the plugin

Configuration keys are dynamic key/value entries in the database. They can be created via PHP or via the onInstall trigger. 
However we recommend creating them via the Trigger, as all KV entries specified here, will be purged upon removal of a plugin, cleaning up leftovers.
Manual created keys, will not be removed.

The structure is as follows:

\verbatim
{
	"display_hello_world": true
}
\endverbatim

The following data types are supported:

- string
- integer
- array (Will be serialized and unserialized)
- double
- NULL
- serialized
- boolean

\subsubsection plugininstalldep activateDependencies - Activate other plugins when installing the plugin

This contains a list of plugin folders to load when installing the plugin.

Example:
\verbatim
["plugin1","plugin2"]
\endverbatim


\subsection pluginuninstall onUninstall - Configuration for plugin removal

This does the same as onInstall, except for when the plugin has been uninstalled and with different options

\subsubsection pluginuninstalldata deleteData - Boolean to delete data on removal

This bool overrides if plugin data should be purged when uninstalling.

\subsubsection pluginuninstalldep deactivateDependencies - Deactivate other plugins when uninstalling the plugin

This contains a list of plugin folders to remove when uninstalling the plugin. Respecting their deleteData property

\warning When using purgeDependencies, leave this list empty as it will lead to conflicts!



Example:
\verbatim
["plugin1","plugin2"]
\endverbatim



\subsubsection pluginuninstallpurge purgeDependencies - Deactivate other plugins when uninstalling the plugin

This contains a list of plugin folders to purge when uninstalling the plugin. 
This property will override deleteData to true and will delete all data of the specified plugins

\warning When using deactivateDependencies, leave this list empty as it will lead to conflicts!



Example:
\verbatim
["plugin1","plugin2"]
\endverbatim


\section hookFileinfo The hook File

The hook file gets called everytime a page has been rendered, called or executed.

It has to be defined in the plugin.json with the hookFile property. Without this file, your plugin cannot be installed.

the hook file has the following context which can be access in the file itself

\verbatim
crisp\core\Plugin $this
\endverbatim

\section createAPI Creating API interface

Crisp offers a feature to hook into the API available at /api/<interface>/<query>

To create a new interface, create a new file in the includes/api/ folder.

To make the API available at /api/exportdata/user

You have to create the file includes/api/exportdata.php

Within this file, you can access the <query>=user with the $_QUERY variable

The file you created, does not have any object context. You need to initialize new classes or use static ones.

Variables:
\verbatim
$_QUERY - This variable holds the string after the interface /api/<interface>/<query>
\endverbatim

\section crons Creating and using crons

Crons are an easy way to execute tasks periodically, such as cleaning up cache files, purging sessions and so on.

Crons are executed in the includes/cron.php file.

\info It is not required to exist, meaning, you plugin will install fine without it.
However if you intend to use the cron system, its required.

Variables in the Cron File:
\verbatim
$_CRON => array(14) {
  ["ID"]=>
  string(5) "11701"
  ["Type"]=>
  string(19) "execute_plugin_cron"
  ["ScheduledAt"]=>
  string(19) "0000-00-00 00:00:00"
  ["CreatedAt"]=>
  string(19) "0000-00-00 00:00:00"
  ["FinishedAt"]=>
  string(19) "0000-00-00 00:00:00"
  ["UpdatedAt"]=>
  string(19) "0000-00-00 00:00:00"
  ["StartedAt"]=>
  string(19) "0000-00-00 00:00:00"
  ["Finished"]=>
  string(1) "0"
  ["Started"]=>
  string(1) "0"
  ["Canceled"]=>
  string(1) "0"
  ["Failed"]=>
  string(1) "0"
  ["Data"]=>
  object(stdClass)#54 (2) {
    ["plugin"]=>
    string(8) "cronjobs"
    ["data"]=>
    string(10) "I am data!"
    ["name"]=>
    string(10) "event_type"
  }
  ["Log"]=>
  NULL
  ["Interval"]=>
  string(8) "5 SECOND"
}
\endverbatim

$_CRON["Data"]["name"] contains the $Type you have provided to identify your crons. Example code:

\verbatim

<?php
switch($_CRON["Data"]["name"]){
    case "purge_cache":
        echo "I am going to purge the cache!". PHP_EOL;
        \crisp\api\lists\Cron::create("execute_plugin_cron", json_encode(array("plugin" => $_CRON["Data"]["plugin"], "data" => "I am data", "name" => "purge_cache")), $_CRON["Interval"]);
        break;
    default:
        echo "Invalid type :(";
}
\endverbatim

\warning CRONs do NOT run in an environment, meaning Config::get will not work like the way it does in the plugin files.
To get the config "helloworld" in the plugin you would have to run Config::get("plugin_PLUGINNAME_helloworld") in the cron file.


\warning It is important to mark the status of a CRON. If it fails to execute, run \crisp\api\lists\Cron::markAsFailed($_CRON["ID"]); if the execution was successful run \crisp\api\lists\Cron::markAsFinished($_CRON["ID"]);
If you don't do this, the cron will stuck at "Running" forever.


\subsection createcron Creating Crons

Creating crons is easy. As per the example above, it is important to repeat the cron creation though, else crons are not executed again. It's rather a scheduler than real UNIX crons.

You can create crons using the object context in code-template files or using the static \crisp\api\lists\Crons::createCron method, there are differences though! See below.

Creating crons when an object context is present:

\verbatim
<?php

$this->createCron("purge_cache", "I am data!", "5 SECOND");
\endverbatim

Creating crons from static methods

\verbatim
<?php

\crisp\api\lists\Cron::create("execute_plugin_cron", json_encode(array("plugin" => $_CRON["Data"]["plugin"], "data" => "I am data", "name" => "purge_cache")), $_CRON["Interval"]);
\endverbatim

The difference between static methods is, you have to define the plugin name yourself and use a different trigger.


\section navbar Adding Items to Navigation Bar

With a recent update, it's now possible to add navigation items programmatically.

This feature makes a good use of the hook file as it ensures its executed everywhere.

Using the function:
\verbatim
\crisp\core\Template::addtoNavbar("LINK_ID", "Link text, "/link_url", "_self", -97);
\endverbatim
You can add links to all navbars which support this feature by using the navbar global

\verbatim
{% for item in GLOBALS.navbar %}
    <li class="nav-item {% if currentPage == item.ID %} active{% endif %}">
        <a target="{{ item.target }}" class="nav-link {% if currentPage == item.ID %} active{% endif %}" href="{{ item.href }}">{{ item.html }}</a>
    </li>
{% endfor %}
\endverbatim

*/
