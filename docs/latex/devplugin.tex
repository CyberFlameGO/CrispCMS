\etocsetnexttocdepth{5}
\localtableofcontents
Plugin documentation for Crisp\hypertarget{devplugin_intro}{}\doxysection{Directory Structure}\label{devplugin_intro}
\begin{DoxyVerb}.
└── plugins/
    └── your_plugin_folder/ - This is your plugin folder name, all lowercase, no spaces
        ├── includes/ - Here lies the PHP code for templates
        │   ├── api/ - Files in here will be executed when calling their api interface => export.php => /api/export/
        │   └── views/ - Files in here will be executed when visiting their page. welcome.php => /en/welcome
        │   └── cron.php - This file will be executed when a cron is called
        ├── templates/ - This is the template directory to store the twig tpls in
        │   └── views/ - Files in here will be rendered when visiting their page. welcome.twig => /en/welcome
        ├── hook.php - The hook file gets called regardless which page is opened
        └── plugin.json - Metadata, the heart of your plugin
\end{DoxyVerb}


It is important that each twig template, needs their respective P\+HP code.

If you want to create a page which can be called at /en/welcome the directory structure has to look like this\+:

\begin{DoxyVerb}.
└── plugins/
    └── your_plugin_folder/
        ├── includes/
        │   ├── api/
        │   └── views/
        │       └── welcome.php - CREATE THIS FILE
        ├── templates/
        │   └── views/
        │       └── welcome.twig - CREATE THIS FILE
        ├── hook.php
        └── plugin.json
\end{DoxyVerb}
\hypertarget{devplugin_metadata}{}\doxysection{plugin.\+json -\/ In detail}\label{devplugin_metadata}
The plugin.\+json file is the heart of your plugin. It can create config keys, translations, languages, uninstall plugins, install plugins and more for you automatically.

Example plugin.\+json \begin{DoxyVerb}{
    "name": "Hello World Plugin",
    "description": "Tutorial plugin plugin for CrispCMS",
    "hookFile": "hook.php",
    "author": "Justin René Back <jback@pixelcatproductions.net>",
    "onInstall": {
        "createTranslationKeys": {
            "en": {
                "hello_world": "Hello World"
            },
            "de": {
                "hello_world": "Hallo Welt"
            }
        },
        "createKVStorageItems": {
            "display_hello_world": true
        },
        "activateDependencies": []
    },
    "onUninstall": {
        "deleteData": true,
        "deactivateDependencies": [],
        "purgeDependencies": []
    }
}
\end{DoxyVerb}
\hypertarget{devplugin_pluginname}{}\doxysubsection{name -\/ The name of your plugin}\label{devplugin_pluginname}
This property contains the full name of your plugin, you can use all characters you want. This will be shown when installing a plugin\hypertarget{devplugin_plugindesc}{}\doxysubsection{description -\/ The description of your plugin}\label{devplugin_plugindesc}
This property defines a description which is shown when listing your plugin. Keep it short\hypertarget{devplugin_pluginhook}{}\doxysubsection{hook\+File -\/ The name of your hook file}\label{devplugin_pluginhook}
A hook file executes code on every page. More about this property is defined below.\hypertarget{devplugin_pluginauthor}{}\doxysubsection{author -\/ Your name, for credits}\label{devplugin_pluginauthor}
Simply your name\hypertarget{devplugin_plugininstall}{}\doxysubsection{on\+Install -\/ Configure your plugin on installation}\label{devplugin_plugininstall}
on\+Install offers a variety of options which get executed when installing the plugin.

All data specified in on\+Install is automatically purged upon removal of the plugin, if delete\+Data is set to true\hypertarget{devplugin_plugininstalltranslation}{}\doxysubsubsection{create\+Translation\+Keys -\/ Creates translations when installing the plugin}\label{devplugin_plugininstalltranslation}
Translations are created using multi-\/dimensional arrays/keys

The structure is as follows\+:

\begin{DoxyVerb}{
    "en": {
        "hello_world": "Hello World"
    },
    "de": {
        "hello_world": "Hallo Welt"
    }
}
\end{DoxyVerb}


You can use any language key, even if it does not exist, it will be created when installing the plugin.\hypertarget{devplugin_plugininstallstorage}{}\doxysubsubsection{create\+K\+V\+Storage\+Items -\/ Creates config keys when installing the plugin}\label{devplugin_plugininstallstorage}
Configuration keys are dynamic key/value entries in the database. They can be created via P\+HP or via the on\+Install trigger. However we recommend creating them via the Trigger, as all KV entries specified here, will be purged upon removal of a plugin, cleaning up leftovers. Manual created keys, will not be removed.

The structure is as follows\+:

\begin{DoxyVerb}{
    "display_hello_world": true
}
\end{DoxyVerb}


The following data types are supported\+:


\begin{DoxyItemize}
\item string
\item integer
\item array (Will be serialized and unserialized)
\item double
\item N\+U\+LL
\item serialized
\item boolean
\end{DoxyItemize}\hypertarget{devplugin_plugininstalldep}{}\doxysubsubsection{activate\+Dependencies -\/ Activate other plugins when installing the plugin}\label{devplugin_plugininstalldep}
This contains a list of plugin folders to load when installing the plugin.

Example\+: \begin{DoxyVerb}["plugin1","plugin2"]
\end{DoxyVerb}
\hypertarget{devplugin_pluginuninstall}{}\doxysubsection{on\+Uninstall -\/ Configuration for plugin removal}\label{devplugin_pluginuninstall}
This does the same as on\+Install, except for when the plugin has been uninstalled and with different options\hypertarget{devplugin_pluginuninstalldata}{}\doxysubsubsection{delete\+Data -\/ Boolean to delete data on removal}\label{devplugin_pluginuninstalldata}
This bool overrides if plugin data should be purged when uninstalling.\hypertarget{devplugin_pluginuninstalldep}{}\doxysubsubsection{deactivate\+Dependencies -\/ Deactivate other plugins when uninstalling the plugin}\label{devplugin_pluginuninstalldep}
This contains a list of plugin folders to remove when uninstalling the plugin. Respecting their delete\+Data property

\begin{DoxyWarning}{Warning}
When using purge\+Dependencies, leave this list empty as it will lead to conflicts!
\end{DoxyWarning}
Example\+: \begin{DoxyVerb}["plugin1","plugin2"]
\end{DoxyVerb}
\hypertarget{devplugin_pluginuninstallpurge}{}\doxysubsubsection{purge\+Dependencies -\/ Deactivate other plugins when uninstalling the plugin}\label{devplugin_pluginuninstallpurge}
This contains a list of plugin folders to purge when uninstalling the plugin. This property will override delete\+Data to true and will delete all data of the specified plugins

\begin{DoxyWarning}{Warning}
When using deactivate\+Dependencies, leave this list empty as it will lead to conflicts!
\end{DoxyWarning}
Example\+: \begin{DoxyVerb}["plugin1","plugin2"]
\end{DoxyVerb}
\hypertarget{devplugin_hookFileinfo}{}\doxysection{The hook File}\label{devplugin_hookFileinfo}
The hook file gets called everytime a page has been rendered, called or executed.

It has to be defined in the plugin.\+json with the hook\+File property. Without this file, your plugin cannot be installed.

the hook file has the following context which can be access in the file itself

\begin{DoxyVerb}crisp\core\Plugin $this
\end{DoxyVerb}
\hypertarget{devplugin_createAPI}{}\doxysection{Creating A\+P\+I interface}\label{devplugin_createAPI}
Crisp offers a feature to hook into the A\+PI available at /api/$<$interface$>$/$<$query$>$

To create a new interface, create a new file in the includes/api/ folder.

To make the A\+PI available at /api/exportdata/user

You have to create the file includes/api/exportdata.\+php

Within this file, you can access the $<$query$>$=user with the \$\+\_\+\+Q\+U\+E\+RY variable

The file you created, does not have any object context. You need to initialize new classes or use static ones.

Variables\+: \begin{DoxyVerb}$_QUERY - This variable holds the string after the interface /api/<interface>/<query>
\end{DoxyVerb}
\hypertarget{devplugin_crons}{}\doxysection{Creating and using crons}\label{devplugin_crons}
Crons are an easy way to execute tasks periodically, such as cleaning up cache files, purging sessions and so on.

Crons are executed in the includes/cron.\+php file.

\textbackslash{}info It is not required to exist, meaning, you plugin will install fine without it. However if you intend to use the cron system, its required.

Variables in the Cron File\+: \begin{DoxyVerb}$_CRON => array(14) {
  ["ID"]=>
  string(5) "11701"
  ["Type"]=>
  string(19) "execute_plugin_cron"
  ["ScheduledAt"]=>
  string(19) "0000-00-00 00:00:00"
  ["CreatedAt"]=>
  string(19) "0000-00-00 00:00:00"
  ["FinishedAt"]=>
  string(19) "0000-00-00 00:00:00"
  ["UpdatedAt"]=>
  string(19) "0000-00-00 00:00:00"
  ["StartedAt"]=>
  string(19) "0000-00-00 00:00:00"
  ["Finished"]=>
  string(1) "0"
  ["Started"]=>
  string(1) "0"
  ["Canceled"]=>
  string(1) "0"
  ["Failed"]=>
  string(1) "0"
  ["Data"]=>
  object(stdClass)#54 (2) {
    ["plugin"]=>
    string(8) "cronjobs"
    ["data"]=>
    string(10) "I am data!"
    ["name"]=>
    string(10) "event_type"
  }
  ["Log"]=>
  NULL
  ["Interval"]=>
  string(8) "5 SECOND"
}
\end{DoxyVerb}


\$\+\_\+\+C\+R\+ON\mbox{[}\char`\"{}\+Data\char`\"{}\mbox{]}\mbox{[}\char`\"{}name\char`\"{}\mbox{]} contains the \$\+Type you have provided to identify your crons. Example code\+:

\begin{DoxyVerb}<?php
switch($_CRON["Data"]["name"]){
    case "purge_cache":
        echo "I am going to purge the cache!". PHP_EOL;
        \crisp\api\lists\Cron::create("execute_plugin_cron", json_encode(array("plugin" => $_CRON["Data"]["plugin"], "data" => "I am data", "name" => "purge_cache")), $_CRON["Interval"]);
        break;
    default:
        echo "Invalid type :(";
}
\end{DoxyVerb}


\begin{DoxyWarning}{Warning}
C\+R\+O\+Ns do N\+OT run in an environment, meaning Config\+::get will not work like the way it does in the plugin files. To get the config \char`\"{}helloworld\char`\"{} in the plugin you would have to run Config\+::get(\char`\"{}plugin\+\_\+\+P\+L\+U\+G\+I\+N\+N\+A\+M\+E\+\_\+helloworld\char`\"{}) in the cron file.

It is important to mark the status of a C\+R\+ON. If it fails to execute, run \textbackslash{}crisp\textbackslash{}api\textbackslash{}lists\textbackslash{}\+Cron\+::mark\+As\+Failed(\$\+\_\+\+C\+R\+ON\mbox{[}\char`\"{}\+I\+D\char`\"{}\mbox{]}); if the execution was successful run \textbackslash{}crisp\textbackslash{}api\textbackslash{}lists\textbackslash{}\+Cron\+::mark\+As\+Finished(\$\+\_\+\+C\+R\+ON\mbox{[}\char`\"{}\+I\+D\char`\"{}\mbox{]}); If you don\textquotesingle{}t do this, the cron will stuck at \char`\"{}\+Running\char`\"{} forever.
\end{DoxyWarning}
\hypertarget{devplugin_createcron}{}\doxysubsection{Creating Crons}\label{devplugin_createcron}
Creating crons is easy. As per the example above, it is important to repeat the cron creation though, else crons are not executed again. It\textquotesingle{}s rather a scheduler than real U\+N\+IX crons.

You can create crons using the object context in code-\/template files or using the static \textbackslash{}crisp\textbackslash{}api\textbackslash{}lists\textbackslash{}\+Crons\+::create\+Cron method, there are differences though! See below.

Creating crons when an object context is present\+:

\begin{DoxyVerb}<?php

$this->createCron("purge_cache", "I am data!", "5 SECOND");
\end{DoxyVerb}


Creating crons from static methods

\begin{DoxyVerb}<?php

\crisp\api\lists\Cron::create("execute_plugin_cron", json_encode(array("plugin" => $_CRON["Data"]["plugin"], "data" => "I am data", "name" => "purge_cache")), $_CRON["Interval"]);
\end{DoxyVerb}


The difference between static methods is, you have to define the plugin name yourself and use a different trigger.\hypertarget{devplugin_navbar}{}\doxysection{Adding Items to Navigation Bar}\label{devplugin_navbar}
With a recent update, it\textquotesingle{}s now possible to add navigation items programmatically.

This feature makes a good use of the hook file as it ensures its executed everywhere.

Using the function\+: \begin{DoxyVerb}\crisp\core\Template::addtoNavbar("LINK_ID", "Link text, "/link_url", "_self", -97);
\end{DoxyVerb}
 You can add links to all navbars which support this feature by using the navbar global

\begin{DoxyVerb}{% for item in GLOBALS.navbar %}
    <li class="nav-item {% if currentPage == item.ID %} active{% endif %}">
        <a target="{{ item.target }}" class="nav-link {% if currentPage == item.ID %} active{% endif %}" href="{{ item.href }}">{{ item.html }}</a>
    </li>
{% endfor %}
\end{DoxyVerb}
 